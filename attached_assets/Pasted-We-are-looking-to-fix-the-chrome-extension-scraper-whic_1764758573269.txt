We are looking to fix the chrome extension scraper which appears to "freeze" upon launch where no buttons, input fields or dropdowns can be selected. Here is a report generated by ai which could fix the issue:Background: Chrome Extension CSP and Allowed Resources

By default, Chrome extension pages (popup, options, dashboard, etc.) enforce a strict Content Security Policy: only scripts and objects packaged inside the extension itself are allowed
developer.chrome.com
stackoverflow.com
. In practice this means external scripts, styles or frames (from other domains) are blocked unless explicitly allowed in manifest.json. For example, the manifest’s content_security_policy must list any external hosts you need
stackoverflow.com
. Notably, the default policy (script-src 'self'; object-src 'self') does not include a default-src or frame-src, which by CSP rules effectively means any other resource types (including iframes) are permitted – but only if those resources themselves do not forbid loading. In other words, Chrome will allow your extension to create an <iframe> to any URL, but if the target page’s own CSP or X-Frame-Options disallows framing, the load will be blocked.

Diagnosis: “Framing X violates CSP” and UI Freeze

The console error “Framing ‘https://gettyimages.my.site.com/’ violates the following Content Security Policy directive: … The request has been blocked.” indicates the extension tried to embed a GettyImages URL in a frame, but GettyImages’ CSP forbids it. Getty’s server has likely set a Content-Security-Policy header with a frame-ancestors directive (e.g. frame-ancestors 'self') that prevents other domains (including your extension’s chrome-extension:// origin) from framing it
stackoverflow.com
. Thus the browser blocked the frame load.

Because that iframe load was attempted immediately on dashboard load, the blocking may have halted further script execution. Uncaught errors or blocked loads in an extension page can stop initialization scripts from running, so event listeners (for dropdowns, buttons, etc.) never get bound. The result is a “frozen” UI: elements render but clicks or typing do nothing because the JavaScript never attached handlers. In practice, a CSP block throws an error in the console and prevents that resource (frame) from loading, which can cascade into other failures in your page script.

Effects on the Dashboard UI

Blocked frame covers UI. If your code creates an <iframe> element as part of the UI (for embedding Getty content), the frame might still occupy space in the layout even when empty. If it covers the page, it can intercept all clicks and keystrokes, making the underlying UI unresponsive.

Scripts aborted. If the frame creation or load is done in script and it triggers a CSP violation, the script may throw an exception (or at least the load is aborted). Any initialization code after that point (such as adding event listeners) might never run.

Inline handlers blocked. In addition, Chrome extension CSP forbids inline scripts and event handlers altogether
stackoverflow.com
stackoverflow.com
. For example, <button onclick="..."> will not fire (the browser refuses it). If your HTML used inline onclick or <script> tags, those will silently be ignored, also breaking interactivity.

Likely Culprit: GettyImages Frame

It appears the extension’s dashboard is trying to iframe or open https://gettyimages.my.site.com/. Getty’s site (or its parent app) likely sends CSP headers preventing being framed. The error message confirms Getty’s CSP is blocking the frame. Chrome can’t override this: extension CSP settings cannot force another domain to allow being framed. The only ways to display Getty content would be to open it in a top-level tab/window or fetch its data differently (e.g. via an API or background script), not by embedding it in the extension’s HTML.

Misconfiguration: Inline Scripts and Handlers

Separately, check dashboard.html/dashboard.js for any inline JavaScript. Under the extension CSP, no inline JS is allowed
developer.chrome.com
stackoverflow.com
. This means:

Remove any onclick="…" or other inline event attributes. Instead, use element.addEventListener(...) in your JavaScript file to bind clicks (as shown in [43]).

Ensure all <script> tags are external (no <script>…</script> blocks with code in the HTML).

Load your script at the end of <body> or after the DOM so that elements exist when you query them.

Failing to do this can make your page load with missing handlers. For example, one developer fixed a similar CSP error by replacing onclick="myFunction()" with a JS listener after DOMContentLoaded
stackoverflow.com
. The same applies here: migrate all event handlers into dashboard.js and attach via addEventListener.

Diagnosing the Freeze

To confirm the cause, open DevTools on the extension page (right-click the popup or load the dashboard and inspect it). Look for any errors besides the Getty frame message. Typical telltale messages are “Refused to execute inline script…” (indicating inline JS was blocked) or any JS exceptions in dashboard.js. Also check if the DOM actually has the iframe element – if so, try removing it to see if the UI becomes responsive.

Recommendations and Fixes

Remove or replace the Getty iframe. If your dashboard doesn’t absolutely need to embed Getty’s page, delete that code. If you need Getty images, consider using Getty’s API or opening the content in a new tab. For example, convert the link to window.open('https://gettyimages.my.site.com/...') which the user can view outside the extension UI.

Use offscreen/background processing. If you need to scrape or fetch data from gettyimages.my.site.com, do it in a background/script context rather than trying to show the page. Chrome’s Manifest V3 offers the Offscreen Documents API: you can create a hidden offscreen document and load a URL into an <iframe> there
stackoverflow.com
. A content script injected into that offscreen iframe could then parse the DOM and send data back to your extension. This bypasses showing it in the UI and works around CSP frame-ancestor rules (since you can remove X-Frame-Options via declarativeNetRequest or use the offscreen). Woxxom’s answer outlines this approach: use chrome.offscreen.createDocument, inject your content script with allFrames: true, load the iframe, then scrape and message results
stackoverflow.com
.

Update manifest.json. Ensure your manifest’s CSP and permissions allow everything your scripts need. You cannot whitelist Getty’s domain for framing, but if you load any scripts or resources from external hosts, they must be in the CSP. (For instance, if you actually needed to run a script from Getty’s domain, you’d add it to content_security_policy – but note that many domains cannot be added due to Chrome’s restrictions on wildcards
stackoverflow.com
.)

Check web_accessible_resources. If your dashboard page is being opened via a chrome-extension:// URL and you try to fetch or embed images or HTML from that, those assets must be listed as web-accessible if loading into iframes. This is typically for exposing extension content to web pages, so it may not apply here.

Avoid inline JS. Revisit every <script> and event attribute in dashboard.html. Move logic into dashboard.js, and attach handlers on DOMContentLoaded as shown in [43]. For example:

document.addEventListener('DOMContentLoaded', () => {
  document.querySelector('button').addEventListener('click', onButtonClick);
});


This ensures the script runs under the allowed CSP and actually binds the click.

Graceful error handling. Add try/catch around code that creates iframes or loads external data. That way a CSP block won’t throw an uncaught error and halt your entire script. At minimum, detect failures and proceed without that content.

Test with Developer Mode. In chrome://extensions, load your unpacked extension and click “Reload”. Open the dashboard and watch console logs live. The CSP block should appear as an error; after removing the offending code, the error should vanish and the UI should become interactive.

Comprehensive Performance and Architectural Audit: Diagnosing UI Freeze in StepGallery v3.0.4 MV31. Executive Summary: Core Findings and Strategic Action PlanThe investigation into the immediate freezing and unresponsiveness of the StepGallery extension dashboard UI (Side Panel) upon loading reveals that the issue is primarily rooted in architectural choices governing initialization flow and inter-process communication (IPC) vulnerability, rather than the observed external Content Security Policy (CSP) violation.1.1 Diagnosis: Primary and Secondary BottlenecksThe performance analysis identifies a critical Primary Bottleneck residing in the Content Script thread. The large, bundled JavaScript file, content-bundle.js, is mandated to execute synchronously as an Immediately Invoked Function Expression (IIFE) immediately after the host page finishes loading (run_at: document_end).1 This initial burst of synchronous execution, which includes the instantiation and initialization of numerous utility classes, monopolizes the browser's main thread, inducing "jank" that prevents the processing of UI updates and crucial IPC messages originating from the Side Panel. The Content Script effectively starves the render process of resources needed for smooth UI operation.1The Secondary Bottleneck concerns the integrity of the Service Worker's IPC mechanism. The Service Worker (background.js) directly calls the router.handle() method within its primary message listener (chrome.runtime.onMessage.addListener) without adequate exception handling.1 This wrapper lacks a comprehensive try...catch block. Consequently, if an initialization message from the dashboard triggers any synchronous error within the complex message handling logic—such as a failure during state parsing or accessing an undefined object—the exception propagates upward. This catastrophic failure can crash or destabilize the Service Worker thread, leading to a silent termination or disconnection that the Side Panel interprets as an indefinite freeze while awaiting an unresolvable response.11.2 High-Priority Refactoring RecommendationsTo achieve immediate stability and long-term performance gains, the following architectural shifts are necessary:Decompose and Decouple Monolithic Script: The voluminous content-bundle.js IIFE must be dismantled. The application should adopt asynchronous loading patterns by dividing the monolithic bundle into smaller, functionally isolated modules. These modules should be loaded dynamically using native import() or via a modern bundler (like Rollup or ESBuild) configured for code splitting. The instantiation of non-critical, computationally heavy utilities (such as InputSanitizer and MemoryMonitor) must be deferred until they are explicitly invoked by active operations, adhering to the principle of Lazy Instantiation.Harden Inter-Process Communication (IPC): The Service Worker's resilience must be prioritized. Comprehensive try...catch blocks must be implemented surrounding the synchronous invocation of router.handle() within chrome.runtime.onMessage.addListener in background.js.1 Furthermore, all complex MessageRouter handlers must be structurally guaranteed to be asynchronous, immediately returning true to signal a delayed response, and resolving the eventual operation status via the provided sendResponse promise callback.1.3 Summary of CSP Impact AssessmentThe reported Getty Images Content Security Policy violation log (likely pertaining to directives such as frame-ancestors) is determined to be an indirect contributor to the overall perceived instability. The CSP violation itself does not cause the Side Panel UI to freeze. The Side Panel is an isolated Chrome extension page, separate from the host tab, and thus its rendering is not constrained by the host site’s CSP.2 However, a strict external CSP does block the NetworkMonitor's attempt at inline script injection for API monitoring, forcing a logging event and subsequent reliance on slower DOM-based extraction methods. This failure adds to the Content Script’s initial processing overhead and exacerbates the existing synchronous initialization bottlenecks.2. Architectural Review of the Manifest V3 EcosystemThe StepGallery extension relies on the Chrome Manifest V3 service worker model, which necessitates precise synchronization between three distinct, isolated runtime contexts: the Content Script, the Service Worker, and the Side Panel UI.2.1 MV3 Process Model: Content Script, Side Panel, and Service Worker InteractionThe extension utilizes the Manifest V3 architecture, deploying a Service Worker (background.js) as the persistent event handler and central hub for all application logic.1 Communication across contexts relies entirely on asynchronous messaging, primarily through chrome.runtime.sendMessage. The dashboard UI is implemented as a dedicated side_panel defined by src/ui/dashboard/dashboard.html.1 Crucially, the Side Panel operates within its own rendering process, guaranteeing isolation from the resource contention and potential crashes of the active host webpage.The Content Script executes the bundled code via content-bundle.js, configured to run at document_end.1 When the user activates the Side Panel, the dashboard.js script (implied to be attached to dashboard.html) immediately attempts to establish a connection with the Service Worker and fetch initial status data, such as SETTINGS_GET or GET_IMAGES. The core performance issue arises when this critical IPC dependency chain encounters a blockage. If the Service Worker is delayed by its own initialization or by synchronously executing heavy tasks, the Side Panel thread—waiting for the necessary configuration and status response—will stall, resulting in the immediate perception of a frozen, unresponsive UI. The architecture is sensitive to any non-asynchronous delay in the Service Worker's response path.2.2 Analysis of StepGallery Initialization Chain (background.js and content-main.js)The initialization sequence begins in the Service Worker when Chrome executes background.js (the Service Worker entry point). This file immediately calls the asynchronous initialize() function.1 The first critical step within this function is: await state.initialize();.1The state.initialize() method is designed to perform asynchronous I/O operations, retrieving persistent configuration data and the collected image array (collectedImages) using chrome.storage.local.get().1 Although the await keyword ensures the Service Worker waits for the disk I/O to complete before proceeding, the Service Worker remains available to handle concurrent messages. A functional vulnerability exists if the logic executed immediately after the I/O completion, or within any of the Service Worker's message handlers, performs heavy synchronous computation, particularly the synchronous parsing of potentially large data structures like a sizable collectedImages array retrieved from storage. If this occurs simultaneously with an initial dashboard request, the Service Worker's main event loop—responsible for processing all IPC—is blocked.Concurrently, the Content Script loads the enormous content-bundle.js file, which is architecturally distinct from the Service Worker's startup. The content script contains the core business logic, including the initialize() function defined within content-main.js (as bundled). This initial loading and execution of the monolithic IIFE, coupled with the Service Worker’s latency, creates two parallel vectors for thread blockage that ultimately lead to the UI freeze. The analysis therefore suggests that the Content Script’s CPU spike is the most likely initial thread blocker in the tab's process, compounding any latent delays in the Service Worker's message response time.3. Deep Dive into Synchronous Initialization BottlenecksThe dominant architectural problem contributing to the UI freeze is the forced synchronous execution of a massive codebase during two separate initialization routines.3.1 Code Cluster Analysis: The Content Script IIFE OverheadThe content-bundle.js is engineered by concatenating thirteen separate source modules via the build.py script into a single Immediately Invoked Function Expression (IIFE).1 This design decision, while simplifying deployment and meeting certain MV3 requirements, forces the browser to parse and execute thousands of lines of logic within one single, uninterruptible task. When the Content Script is injected and executes at document_end 1, this bulk operation is highly likely to exceed the browser's responsiveness threshold (often cited around 50 milliseconds), leading to noticeable UI jank.This synchronous payload includes several classes that require significant CPU resources during instantiation:InputSanitizer: The constructor for InputSanitizer immediately compiles complex regular expressions required for security validation, such as checking allowedSelectorChars and defining numerous dangerousPatterns to prevent XSS and path traversal.1 This compulsory regex compilation adds a considerable, unnecessary synchronous cost during every page load, regardless of whether the user interacts with the extension.ToastNotifier: The ToastNotifier performs immediate, synchronous DOM manipulation within its initialization method, including injecting core CSS styles and creating the toast container using document.head.appendChild(style).1 Although minor, this direct DOM work contributes to the initial CPU spike and should be deferred.NetworkMonitor: This utility attempts to inject() custom inline scripts immediately to override browser native functions (fetch, XMLHttpRequest) for API monitoring.1 This process, even if gracefully failing due to a strict CSP (as detailed in Section 4), involves synchronous DOM manipulation (creating, appending, and removing a script element) that consumes valuable startup time.The necessity of executing this deep component initialization upfront prevents the browser's main thread from rapidly completing necessary IPC handshakes with the Side Panel. The architecture should move away from this high-cost, synchronous upfront pattern towards an on-demand, lazy-loaded structure.Table 1 details the core Content Script components and their initialization overhead.Table 1: Content Script Initialization Cost & Refactoring RoadmapComponent ClassFileInitial CPU CostArchitectural SolutionJustificationInputSanitizersrc/shared/input-sanitizer.jsHigh (Regex compilation)Lazy Instantiation via Factory/GetterDefer synchronous, CPU-intensive setup until first required use.ContentHashersrc/shared/content-hasher.jsMedium (API import/Setup)Defer InstantiationOnly needed during active pagination loop.ToastNotifiersrc/shared/toast-notifier.jsMedium (DOM injection)Deferred Execution (setTimeout(0))Decouple DOM manipulation from initial script execution loop.NetworkMonitorsrc/content/network-monitor.jsMedium (Injection attempt/CSP check)Deferred Execution (setTimeout(1000))Spread initial script load across time, avoiding immediate CPU spike.13.2 Service Worker IPC Vulnerability: The Unhandled Error PathThe Service Worker's message handling structure presents a significant architectural weakness that contributes to the perceived freeze. As seen in background.js, all incoming messages are routed through a synchronous wrapper 1:JavaScriptchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  const result = router.handle(message, sender, sendResponse);
  return result;
});
This construction is problematic because the MessageRouter.handle() execution is not wrapped in explicit error control mechanisms such as try...catch.1 If any synchronous code path within the router's execution chain throws an exception—for instance, during a complex operation like handleSettingsGet or handleGetImages when accessing state or dependencies—the exception propagates and potentially destabilizes the Service Worker.If the Service Worker terminates unexpectedly, the Side Panel, which initiated the message and relies on a response for initialization, will never receive confirmation. Since the Side Panel thread is blocked awaiting this response, it remains indefinitely frozen. The issue is therefore not necessarily a prolonged wait, but an abrupt disconnection caused by the fragility of the synchronous message handler definition.1 This fragility is further compounded by the Service Worker’s dependency on asynchronous disk I/O for state loading, creating a narrow window during which subsequent message handling might fail if dependencies are not fully resolved.3.3 The Dashboard UI Initialization Wait (Hypothetical dashboard.js Analysis)The freezing event occurs immediately after the Side Panel loads, implying that the dashboard's primary script (dashboard.js, which is not fully available for inspection 1) initiates a synchronous blocking operation. It is standard practice for extension UIs to immediately query the Service Worker for persistent configuration and current image data (MESSAGE_TYPES.SETTINGS_GET, MESSAGE_TYPES.GET_IMAGES) to populate the interface elements (imageCount, controls, etc.).1If the dashboard.js sends this initial message synchronously, the UI thread stalls, waiting for the Service Worker to return. When the Service Worker is simultaneously grappling with the fallout of the Content Script's initial CPU spike (Section 3.1) and potentially encountering errors due to the lack of safe message handling (Section 3.2), the necessary response latency is pushed beyond acceptable limits. Furthermore, if the UI is architected to block rendering until all persistent state, particularly the potentially large collectedImages array, is successfully loaded from chrome.storage.local, the cumulative effect of slow I/O and synchronous parsing results in the immediate and severe UI freeze. This suggests a pattern where the UI prioritizes complete data hydration over responsive rendering, exacerbating the performance consequences of delays in the Service Worker or Content Script.4. The Content Security Policy (CSP) and UI ResponsivenessThe reported CSP violation must be contextualized within the security architecture of the browser extension.4.1 External CSP (frame-ancestors) Violation ImpactThe user cited a CSP violation log specifically related to Getty Images, likely involving the frame-ancestors directive. This directive is designed to prevent unauthorized domains from embedding the protected web page within a frame or iframe, serving as a defense against clickjacking.2The analysis confirms that this external policy is a red herring regarding the dashboard UI freeze. The Side Panel loads in its own context, governed by the Chrome extension framework, isolated from the host page's CSP. Consequently, the Getty Images CSP does not directly prevent the Side Panel from rendering or functioning.However, the external CSP does impose constraints on the Content Script. The NetworkMonitor class attempts to inject inline JavaScript to monitor network requests for API-based pagination.1 Strict host page script-src policies will block this injection, forcing the NetworkMonitor to gracefully degrade its functionality.1 This failure forces the extension to rely on slower, DOM-based pagination methods and generates error logging, which marginally contributes to the overall processing overhead during the critical initialization phase.4.2 Internal CSP Review (manifest.json)The extension's internal security posture, defined in manifest.json, directly influences the performance architecture:JSON{
 ...
  "content_security_policy": {
    "extension_pages": "script-src 'self'; object-src 'self'; img-src 'self' data: https:; connect-src 'self' https:; style-src 'self' 'unsafe-inline'"
  }
}
The strict script-src 'self' policy is a core MV3 security requirement, prohibiting code execution from external CDNs or inline <script> tags, ensuring all executable code is local.1 This mandate directly led to the architectural decision to create the content-bundle.js monolith via build.py.1 Thus, the security requirement, while correct for MV3 compliance, is the fundamental reason for the high-cost synchronous code load identified in Section 3.1.The use of an offscreen document for export processing, as noted by the presence of export-worker.html and export-worker.js 1, demonstrates an existing capacity for delegating heavy, long-running tasks (like CSV/XLSX generation using papaparse.min.js and xlsx.full.min.js) off the Service Worker thread. This pattern of thread delegation should be expanded to address the initialization performance issues.5. Proposed Architectural Refactoring and Performance OptimizationTo resolve the UI freeze, a strategy must decouple initialization work from the critical rendering path and harden IPC against fatal errors.5.1 Decoupling Strategy: Deferred Initialization and Lazy LoadingThe analysis necessitates decommissioning the current monolithic approach in favor of modularity and deferral. The Content Script IIFE must be broken down to mitigate the initial CPU spike.Decomposition and Dynamic Loading: The build process should be re-engineered to produce a small entry file and dynamically load feature modules (ImageExtractor, PaginationEngine, etc.) only when they are activated, replacing the synchronous IIFE execution.1Lazy Instantiation: Constructors of CPU-intensive utilities must be protected by late instantiation mechanisms. InputSanitizer, with its regex compilation overhead 1, and ContentHasher should be initialized only when the first data processing or pagination operation is requested, ensuring the initial content script load is minimal.Deferred DOM Operations: DOM manipulation performed by components like ToastNotifier (injecting styles and containers) must be scheduled using non-blocking methods like setTimeout or requestIdleCallback to allow the critical initialization thread to complete unimpeded.15.2 Worker Thread Utilization for Initialization and ComputationThe established use of an Offscreen Document for data export tasks 1 should be extended to handle synchronous initialization tasks, freeing the Service Worker's event loop.Offloading State Processing: After the Service Worker completes its asynchronous I/O read of data (e.g., collectedImages array from storage), any subsequent synchronous parsing, validation, or complex data processing should be delegated to the Offscreen Document. This ensures that the Service Worker remains immediately responsive to low-latency requests from the Side Panel.Concurrency Control: The architecture should use the chrome.alarms API or background timers to schedule non-critical checks, such as MemoryMonitor activation (which runs every 5000ms 1) and gallery auto-detection (which is currently deferred by a short setTimeout(1000) in content-main.js 1), ensuring these operations do not collide with or block the initial UI handshake.5.3 Optimizing State Management and IPCThe fundamental vulnerability in the message handling architecture requires immediate remediation. Based on the analysis, the synchronous IPC pattern, which caused performance regressions in past versions by introducing 10-30 second blocking waits 1, must be eliminated entirely.Safe Message Listener: The chrome.runtime.onMessage.addListener in background.js must be wrapped in try...catch blocks to prevent exceptions from crashing the Service Worker.1Mandatory Asynchronous Responses: All IPC handlers that perform state I/O or complex logic must explicitly return true immediately to signal an asynchronous response and handle the actual response callback via a promise chain, decoupling the Service Worker's event loop from the execution time of the message handler.Preventing Race Conditions: The Service Worker must ensure that any UI query for state (SETTINGS_GET, GET_IMAGES) resolves only after state.initialize() has successfully completed its asynchronous I/O and any synchronous post-I/O processing (potentially delegated to an Offscreen Document) is finished.Table 2 details the necessary IPC flow hardening.Table 2: Critical IPC Flow Analysis and Synchronization RisksFlow StepSourceTargetEvent TypeBlocking VulnerabilityMitigation Strategy1. Initial State LoadSide Panel (dashboard.js)Service Worker (router.handle)Status Request (SYNC)SW blocks if router.handle runs synchronous state reads or throws uncaught exception.1Implement try/catch and enforce asynchronous handling of all status requests.2. Content Script StartBrowserContent Script (IIFE)Script Injection (SYNC)Content thread blocks due to large IIFE execution, starving resources needed for smooth UI IPC.1Decompose IIFE and introduce dynamic module loading.3. SW InitializationService Workerchrome.storage.localstate.initialize() (ASYNC/IO)Follow-up state processing (parsing large image arrays) may block Service Worker after I/O returns.Delegate synchronous post-I/O data processing to Offscreen Document.4. Content Ready SignalContent ScriptService WorkerCORE_INIT (ASYNC)If Content Script is slow (Step 2), this crucial handshake is delayed, holding up UI features dependent on content readiness.Optimize Content Script load time and ensure prompt initiation of CORE_INIT.5.4 Mitigating Performance Regressions (Lessons Learned)The extension previously suffered from a critical performance flaw wherein the Pagination Engine would block the main thread for 10-30 seconds, waiting for a download/page-complete message.1 The fix involved removing this synchronous waiting mechanism and delegating parallel download management entirely to the Service Worker.This historical event confirms a deep-seated architectural tendency to implement blocking control flow for event coordination. The current UI freezing issue is a manifestation of this same systemic design flaw applied to the initialization lifecycle. Future development must rigorously enforce that core operations, such as state loading and environment readiness checks, utilize non-blocking Promise chains or Service Worker message ports for communication, ensuring that no synchronization primitive is introduced that halts the execution context.6. Conclusion and Future Work in MV3 ComplianceThe immediate freezing of the StepGallery dashboard is a direct consequence of cumulative architectural debt stemming from synchronous component loading and vulnerable Service Worker IPC logic. The external CSP violation is an environmental complication, not the root cause. The primary thread blockage originates from the high CPU cost of executing the monolithic content-bundle.js IIFE immediately upon page load.1Resolving this requires a comprehensive shift toward asynchronous, modular MV3 architecture:Refactoring Build Systems: Move away from the concatenation script (build.py) to a modern bundler that supports MV3-compliant dynamic imports, allowing code splitting for on-demand module loading.Mandating Asynchrony: Systematically review the MessageRouter to ensure all handlers return true and utilize Promise resolution for sendResponse, eliminating the risk of fatal synchronous errors in the Service Worker.Prioritizing Thread Delegation: Utilize the existing Offscreen Document to absorb heavy, synchronous tasks related to initial state processing and utility instantiation, thereby guaranteeing low latency and high stability for the primary Service Worker event loop.By adopting these prescribed architectural remediations, the StepGallery extension can leverage the inherent performance benefits of Manifest V3, transforming the user experience from immediate unresponsiveness to fluid, responsive operation. Future work should integrate asynchronous performance profiling tools (performance.measure) to quantify and monitor initialization latency, ensuring that the critical 50ms responsiveness threshold is never violated during startup.